<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#7cc0ff">
<title>–†—É—Å—Å–∫–∞—è –∞–∑–±—É–∫–∞ ‚Äî —É—á–∏–º—Å—è –∏–≥—Ä–∞—è</title>
<style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; -webkit-text-size-adjust: 100%; overscroll-behavior: none; }
  :root {
    --gap: 10px;
    --padding: 14px;
    --cell-size: 110px;
    --cols: 6;
    --radius: 16px;
    --shadow: 0 4px 10px rgba(0,0,0,0.12);
    --shadow-hover: 0 8px 18px rgba(0,0,0,0.18);
    --focus: 2px solid #1e88e5;
    --bg1: #e3f2fd;
    --bg2: #fce4ec;
    --anim: 160ms ease;
    --text: #16324f;
  }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    color: var(--text);
    background: linear-gradient(140deg, #e1f5fe 0%, #f8e9ff 50%, #e0ffe7 100%);
  }
  .wrapper {
    position: relative;
    width: 100%;
    max-width: 100svw;
    height: 100dvh;
    height: 100svh;
    height: 100vh;
    padding-top: calc(var(--padding) + env(safe-area-inset-top));
    padding-right: calc(var(--padding) + env(safe-area-inset-right));
    padding-bottom: calc(var(--padding) + env(safe-area-inset-bottom));
    padding-left: calc(var(--padding) + env(safe-area-inset-left));
    display: grid;
    place-items: center;
    touch-action: manipulation;
  }
  .grid {
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    display: grid;
    grid-template-columns: repeat(var(--cols), minmax(0, var(--cell-size)));
    grid-auto-rows: var(--cell-size);
    gap: var(--gap);
  }

  .card {
    min-width: 0;
    min-height: 0;
    overflow: clip;
    aspect-ratio: 1 / 1;
    display: grid;
    place-items: center;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    background: var(--bg1);
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: transform var(--anim), box-shadow var(--anim), background-color var(--anim);
    outline: none;
    touch-action: manipulation;
  }
  .card:hover { transform: translateZ(0) scale(1.02); box-shadow: var(--shadow-hover); }
  .card:active { transform: translateZ(0) scale(0.98); box-shadow: var(--shadow); }
  .card:focus-visible { outline: var(--focus); outline-offset: 2px; }

  .inner {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: center;
    justify-items: center;
    gap: clamp(4px, calc(var(--cell-size) * 0.06), 14px);
    padding: clamp(6px, calc(var(--cell-size) * 0.10), 18px);
  }
  .letter {
    font-weight: 800;
    font-size: clamp(18px, calc(var(--cell-size) * 0.42), 120px);
    line-height: 1;
  }
  .emoji {
    font-size: clamp(16px, calc(var(--cell-size) * 0.35), 96px);
    line-height: 1;
  }
  .stacked .inner { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr; }

  .label {
    position: absolute;
    inset: auto 8px 8px 8px;
    text-align: center;
    font-size: clamp(10px, 2.6vw, 14px);
    opacity: 0.85;
    color: var(--text);
    pointer-events: none;
  }

  .wrapper.compact { --gap: 6px; --padding: 8px; --radius: 12px; }
  .wrapper.compact .letter { font-size: clamp(16px, calc(var(--cell-size) * 0.38), 110px); }
  .wrapper.compact .emoji  { font-size: clamp(14px, calc(var(--cell-size) * 0.32), 88px); }

  .overlay {
    position: fixed;
    inset: 0;
    background: linear-gradient(180deg, rgba(255,255,255,0.92), rgba(240,248,255,0.92));
    display: grid;
    place-items: center;
    z-index: 9999;
    -webkit-backdrop-filter: blur(8px);
    backdrop-filter: blur(8px);
  }
  .overlay .overlay-box {
    background: white;
    border-radius: 18px;
    padding: 24px 28px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    text-align: center;
    max-width: 80%;
  }
  .overlay h1 { margin: 0 0 8px 0; font-size: 20px; }
  .overlay p { margin: 0; opacity: 0.8; font-size: 14px; }
  .overlay[hidden] { display: none; }

  @media (prefers-reduced-motion: reduce) {
    .card { transition: none; }
    .card:hover, .card:active { transform: none; }
  }
</style>
</head>
<body>
<div class="overlay" id="overlay" role="button" aria-label="–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫" tabindex="0">
  <div class="overlay-box">
    <h1>–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫</h1>
    <p>–≠—Ç–æ –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ –±—É–∫–≤ –Ω–∞ –≤–∞—à–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.</p>
  </div>
</div>

<div class="wrapper" id="wrapper" role="grid" aria-label="–†—É—Å—Å–∫–∞—è –∞–∑–±—É–∫–∞">
  <div class="grid" id="grid"></div>
</div>

<script>
  (function () {
    const items = [
      { l: '–ê', w: '–∞—Ä–±—É–∑',    e: 'üçâ', phrase: '–ê ‚Äî –∞—Ä–±—É–∑' },
      { l: '–ë', w: '–±–∞—Ä–∞–±–∞–Ω',  e: 'ü•Å', phrase: '–ë ‚Äî –±–∞—Ä–∞–±–∞–Ω' },
      { l: '–í', w: '–≤–µ–ª–æ—Å–∏–ø–µ–¥',e: 'üö≤', phrase: '–í ‚Äî –≤–µ–ª–æ—Å–∏–ø–µ–¥' },
      { l: '–ì', w: '–≥—Ä—É—à–∞',    e: 'üçê', phrase: '–ì ‚Äî –≥—Ä—É—à–∞' },
      { l: '–î', w: '–¥–æ–º',      e: 'üè†', phrase: '–î ‚Äî –¥–æ–º' },
      { l: '–ï', w: '–µ–Ω–æ—Ç',     e: 'ü¶ù', phrase: '–ï ‚Äî –µ–Ω–æ—Ç' },
      { l: '–Å', w: '—ë–ª–∫–∞',     e: 'üéÑ', phrase: '–Å ‚Äî —ë–ª–∫–∞' },
      { l: '–ñ', w: '–∂–∏—Ä–∞—Ñ',    e: 'ü¶í', phrase: '–ñ ‚Äî –∂–∏—Ä–∞—Ñ' },
      { l: '–ó', w: '–∑–∞—è—Ü',     e: 'üê∞', phrase: '–ó ‚Äî –∑–∞—è—Ü' },
      { l: '–ò', w: '–∏–≥—Ä–∞',     e: 'üéÆ', phrase: '–ò ‚Äî –∏–≥—Ä–∞' },
      { l: '–ô', w: '–π–æ–≥–∞',     e: 'üßò', phrase: '–ô ‚Äî –π–æ–≥–∞' },
      { l: '–ö', w: '–∫–æ—Ç',      e: 'üê±', phrase: '–ö ‚Äî –∫–æ—Ç' },
      { l: '–õ', w: '–ª–∏—Å–∞',     e: 'ü¶ä', phrase: '–õ ‚Äî –ª–∏—Å–∞' },
      { l: '–ú', w: '–º—è—á',      e: '‚öΩ', phrase: '–ú ‚Äî –º—è—á' },
      { l: '–ù', w: '–Ω–æ—Å–æ—Ä–æ–≥',  e: 'ü¶è', phrase: '–ù ‚Äî –Ω–æ—Å–æ—Ä–æ–≥' },
      { l: '–û', w: '–æ—Å—å–º–∏–Ω–æ–≥', e: 'üêô', phrase: '–û ‚Äî –æ—Å—å–º–∏–Ω–æ–≥' },
      { l: '–ü', w: '–ø–æ–µ–∑–¥',    e: 'üöÇ', phrase: '–ü ‚Äî –ø–æ–µ–∑–¥' },
      { l: '–†', w: '—Ä–∞–∫–µ—Ç–∞',   e: 'üöÄ', phrase: '–† ‚Äî —Ä–∞–∫–µ—Ç–∞' },
      { l: '–°', w: '—Å–æ–ª–Ω—Ü–µ',   e: '‚òÄÔ∏è', phrase: '–° ‚Äî —Å–æ–ª–Ω—Ü–µ' },
      { l: '–¢', w: '—Ç–∏–≥—Ä',     e: 'üêØ', phrase: '–¢ ‚Äî —Ç–∏–≥—Ä' },
      { l: '–£', w: '—É—Ç–∫–∞',     e: 'ü¶Ü', phrase: '–£ ‚Äî —É—Ç–∫–∞' },
      { l: '–§', w: '—Ñ–ª–∞–º–∏–Ω–≥–æ', e: 'ü¶©', phrase: '–§ ‚Äî —Ñ–ª–∞–º–∏–Ω–≥–æ' },
      { l: '–•', w: '—Ö–æ–º—è–∫',    e: 'üêπ', phrase: '–• ‚Äî —Ö–æ–º—è–∫' },
      { l: '–¶', w: '—Ü–∏—Ä–∫',     e: 'üé™', phrase: '–¶ ‚Äî —Ü–∏—Ä–∫' },
      { l: '–ß', w: '—á–∞–π–Ω–∏–∫',   e: 'ü´ñ', phrase: '–ß ‚Äî —á–∞–π–Ω–∏–∫' },
      { l: '–®', w: '—à–∞—Ä–∏–∫',    e: 'üéà', phrase: '–® ‚Äî —à–∞—Ä–∏–∫' },
      { l: '–©', w: '—â—ë—Ç–∫–∞',    e: 'ü™•', phrase: '–© ‚Äî —â—ë—Ç–∫–∞' },
      { l: '–™', w: '—Ç–≤—ë—Ä–¥—ã–π –∑–Ω–∞–∫', e: 'üß±', phrase: '–™ ‚Äî —Ç–≤—ë—Ä–¥—ã–π –∑–Ω–∞–∫' },
      { l: '–´', w: '–±—É–∫–≤–∞ —ã',  e: 'üôÇ', phrase: '–´ ‚Äî –±—É–∫–≤–∞ —ã' },
      { l: '–¨', w: '–º—è–≥–∫–∏–π –∑–Ω–∞–∫', e: 'üß∏', phrase: '–¨ ‚Äî –º—è–≥–∫–∏–π –∑–Ω–∞–∫' },
      { l: '–≠', w: '—ç—Å–∫–∏–º–æ',   e: 'üç¶', phrase: '–≠ ‚Äî —ç—Å–∫–∏–º–æ' },
      { l: '–Æ', w: '—é–±–∫–∞',     e: 'üëó', phrase: '–Æ ‚Äî —é–±–∫–∞' },
      { l: '–Ø', w: '—è–≥–æ–¥–∞',    e: 'üçì', phrase: '–Ø ‚Äî —è–≥–æ–¥–∞' }
    ];

    const palette = [
      '#FFCDD2','#F8BBD0','#E1BEE7','#D1C4E9','#C5CAE9','#BBDEFB','#B3E5FC',
      '#B2EBF2','#B2DFDB','#C8E6C9','#DCEDC8','#F0F4C3','#FFF9C4','#FFECB3',
      '#FFE0B2','#FFCCBC','#D7CCC8','#CFD8DC'
    ];

    const wrapper = document.getElementById('wrapper');
    const grid = document.getElementById('grid');
    const overlay = document.getElementById('overlay');

    let audioEnabled = false;
    let currentCols = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || 6;
    let selectedVoice = null;

    function buildGrid() {
      const frag = document.createDocumentFragment();
      items.forEach((it, idx) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.setAttribute('role', 'button');
        card.setAttribute('tabindex', '0');
        card.setAttribute('aria-label', it.phrase);
        card.dataset.index = String(idx);
        card.style.background = palette[idx % palette.length];

        const inner = document.createElement('div');
        inner.className = 'inner';

        const letter = document.createElement('div');
        letter.className = 'letter';
        letter.textContent = it.l;

        const emoji = document.createElement('div');
        emoji.className = 'emoji';
        emoji.textContent = it.e;

        inner.appendChild(letter);
        inner.appendChild(emoji);
        card.appendChild(inner);

        card.addEventListener('click', () => speak(it.phrase));
        card.addEventListener('keydown', (e) => {
          const key = e.key;
          if (key === 'Enter' || key === ' ') {
            e.preventDefault();
            speak(it.phrase);
            return;
          }
          const idx = Number(card.dataset.index);
          let targetIndex = null;
          if (key === 'ArrowLeft') targetIndex = idx - 1;
          else if (key === 'ArrowRight') targetIndex = idx + 1;
          else if (key === 'ArrowUp') targetIndex = idx - currentCols;
          else if (key === 'ArrowDown') targetIndex = idx + currentCols;
          if (targetIndex !== null) {
            e.preventDefault();
            if (targetIndex >= 0 && targetIndex < items.length) {
              const target = grid.querySelector(`.card[data-index="${targetIndex}"]`);
              target && target.focus();
            }
          }
        });

        frag.appendChild(card);
      });
      grid.appendChild(frag);
    }

    function debounce(fn, delay) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(null, args), delay);
      };
    }

    function getViewportSize() {
      const vv = window.visualViewport;
      if (vv) return { w: Math.floor(vv.width), h: Math.floor(vv.height) };
      const de = document.documentElement;
      return { w: Math.floor(de.clientWidth), h: Math.floor(de.clientHeight) };
    }

    function px(n) { return `${Math.max(0, Math.floor(n))}px`; }

    function fitGrid() {
      const { w: vw, h: vh } = getViewportSize();
      const csGrid = getComputedStyle(grid);
      const csWrap = getComputedStyle(wrapper);
      const gap = parseFloat(csGrid.getPropertyValue('--gap')) || parseFloat(csGrid.gap) || 0;
      const padL = parseFloat(csWrap.paddingLeft) || 0;
      const padR = parseFloat(csWrap.paddingRight) || 0;
      const padT = parseFloat(csWrap.paddingTop) || 0;
      const padB = parseFloat(csWrap.paddingBottom) || 0;

      const portrait = vh >= vw;
      const range = portrait ? [3, 6] : [5, 10];

      let best = null;

      for (let cols = range[0]; cols <= range[1]; cols++) {
        const rows = Math.ceil(items.length / cols);
        const cellByWidth = Math.floor((vw - (cols - 1) * gap - (padL + padR)) / cols);
        const totalHeight = rows * cellByWidth + (rows - 1) * gap + (padT + padB);
        if (cellByWidth <= 0) continue;
        if (totalHeight <= vh) {
          if (!best || cellByWidth > best.cell) {
            best = { cols, cell: cellByWidth, rows };
          }
        }
      }

      const hadCompact = wrapper.classList.contains('compact');
      if (!best) {
        if (!hadCompact) {
          wrapper.classList.add('compact');
          return fitGrid();
        } else {
          // fallback: pick the largest cell that fits width with max cols in range
          let fallback = null;
          for (let cols = range[0]; cols <= range[1]; cols++) {
            const cellByWidth = Math.floor((vw - (cols - 1) * gap - (padL + padR)) / cols);
            if (cellByWidth <= 0) continue;
            if (!fallback || cellByWidth > fallback.cell) fallback = { cols, cell: cellByWidth };
          }
          best = fallback || { cols: portrait ? range[0] : range[1], cell: 64 };
        }
      } else {
        if (hadCompact) {
          wrapper.classList.remove('compact');
          // Re-evaluate with non-compact spacings
          return fitGrid();
        }
      }

      currentCols = best.cols;
      document.documentElement.style.setProperty('--cols', String(best.cols));
      document.documentElement.style.setProperty('--cell-size', px(best.cell));

      requestAnimationFrame(() => postFitAdjust());
      adjustStacking(best.cell);
    }

    function postFitAdjust() {
      const maxIterations = 400;
      let iterations = 0;

      function step() {
        const overflowX = wrapper.scrollWidth > wrapper.clientWidth;
        const overflowY = wrapper.scrollHeight > wrapper.clientHeight;
        if (!overflowX && !overflowY) return;
        const current = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 100;
        const next = Math.max(1, Math.floor(current - 2));
        if (next === current || iterations++ > maxIterations) return;
        document.documentElement.style.setProperty('--cell-size', px(next));
        adjustStacking(next);
        requestAnimationFrame(step);
      }
      step();
    }

    function adjustStacking(cell) {
      const stacked = cell < 96;
      grid.classList.toggle('stacked', stacked);
    }

    function chooseVoice() {
      const voices = window.speechSynthesis.getVoices();
      if (!voices || !voices.length) return null;
      const byExact = voices.find(v => (v.lang || '').toLowerCase() === 'ru-ru');
      if (byExact) return byExact;
      const byRu = voices.find(v => (v.lang || '').toLowerCase().startsWith('ru'));
      if (byRu) return byRu;
      const similar = voices.find(v => /(uk|be|bg|sr)/i.test(v.lang || ''));
      return similar || voices[0];
    }

    function primeSpeech() {
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(' ');
        u.volume = 0;
        u.rate = 1;
        u.pitch = 1;
        u.lang = 'ru-RU';
        const v = chooseVoice();
        if (v) u.voice = v;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    function speak(text) {
      if (!audioEnabled) return;
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 0.95;
        u.pitch = 1.0;
        u.lang = 'ru-RU';
        if (!selectedVoice) selectedVoice = chooseVoice();
        if (selectedVoice) u.voice = selectedVoice;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    function enableAudio() {
      audioEnabled = true;
      selectedVoice = chooseVoice();
      primeSpeech();
      overlay.setAttribute('hidden', '');
      setTimeout(() => {
        // focus first card for accessibility
        const first = grid.querySelector('.card');
        first && first.focus();
      }, 0);
    }

    overlay.addEventListener('click', enableAudio);
    overlay.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        enableAudio();
      }
    });

    window.speechSynthesis.addEventListener('voiceschanged', () => {
      selectedVoice = chooseVoice();
    });

    buildGrid();
    const onResize = debounce(fitGrid, 50);
    window.addEventListener('load', fitGrid, { passive: true });
    window.addEventListener('resize', onResize, { passive: true });
    window.addEventListener('orientationchange', onResize, { passive: true });
    if (window.visualViewport) window.visualViewport.addEventListener('resize', onResize, { passive: true });
  })();
</script>
</body>
</html>