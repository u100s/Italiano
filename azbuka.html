<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#9cd8ff">
<title>–ê–∑–±—É–∫–∞ ‚Äî –∏–≥—Ä–∞–µ–º –∏ –≥–æ–≤–æ—Ä–∏–º</title>
<style>
  :root {
    --pad: 12px;
    --gap: 10px;
    --cell-size: 100px;
    --radius: 16px;
    --shadow: 0 6px 16px rgba(0,0,0,0.15);
    --shadow-hover: 0 10px 24px rgba(0,0,0,0.18);
    --focus: #1e88e5;
    --bg1: #f2fbff;
    --bg2: #fef6ff;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    color: #1b1b1b;
    background: radial-gradient(1200px 800px at 20% 10%, var(--bg1), transparent 70%),
                radial-gradient(1000px 700px at 80% 90%, var(--bg2), transparent 70%),
                linear-gradient(180deg, #e9f7ff 0%, #fff5fb 100%);
  }
  .app {
    width: 100vw;
    height: 100vh;
    height: 100svh;
    height: 100dvh;
    padding: env(safe-area-inset-top) env(safe-area-inset-right)
             env(safe-area-inset-bottom) env(safe-area-inset-left);
    display: grid;
    place-items: center;
  }
  .grid-wrap {
    width: 100%;
    height: 100%;
    padding: var(--pad);
    display: grid;
  }
  .grid {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: repeat(6, var(--cell-size));
    grid-auto-rows: var(--cell-size);
    gap: var(--gap);
    justify-content: center;
    align-content: center;
    touch-action: manipulation;
  }
  .tile {
    background: #ffffff;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    display: grid;
    place-items: center;
    user-select: none;
    cursor: pointer;
    transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
    outline: none;
    aspect-ratio: 1 / 1;
  }
  .tile:focus-visible {
    box-shadow: 0 0 0 4px rgba(30,136,229,0.25), var(--shadow-hover);
  }
  .tile:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: var(--shadow-hover);
  }
  .tile:active {
    transform: translateY(0) scale(0.98);
    box-shadow: var(--shadow);
    filter: brightness(0.98);
  }
  .tile-content {
    width: 90%;
    height: 90%;
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: center;
    justify-items: center;
    gap: clamp(4px, calc(var(--cell-size) * 0.06), 16px);
  }
  .letter {
    font-weight: 800;
    line-height: 1;
    font-size: clamp(28px, calc(var(--cell-size) * 0.52), 100px);
  }
  .emoji {
    font-size: clamp(24px, calc(var(--cell-size) * 0.42), 72px);
  }
  @media (max-width: 430px) {
    .tile-content {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
      gap: clamp(2px, calc(var(--cell-size) * 0.04), 10px);
    }
    .letter {
      font-size: clamp(26px, calc(var(--cell-size) * 0.48), 84px);
    }
    .emoji {
      font-size: clamp(22px, calc(var(--cell-size) * 0.4), 64px);
    }
  }
  .compact .tile-content {
    gap: clamp(2px, calc(var(--cell-size) * 0.04), 10px);
  }
  .compact .letter {
    font-size: clamp(24px, calc(var(--cell-size) * 0.48), 90px);
  }
  .compact .emoji {
    font-size: clamp(20px, calc(var(--cell-size) * 0.36), 60px);
  }

  .overlay {
    position: fixed;
    inset: 0;
    z-index: 10;
    background: rgba(255,255,255,0.82);
    backdrop-filter: blur(8px);
    display: grid;
    place-items: center;
    padding: 24px;
  }
  .overlay.hide {
    opacity: 0;
    pointer-events: none;
    transition: opacity 200ms ease;
  }
  .overlay-card {
    background: linear-gradient(180deg, #ffffffbf, #ffffffa8);
    border-radius: 20px;
    box-shadow: 0 12px 32px rgba(0,0,0,0.18);
    padding: 28px 24px;
    max-width: 520px;
    text-align: center;
    color: #10324a;
  }
  .overlay-emoji {
    font-size: 48px;
    margin-bottom: 12px;
  }
  .overlay-title {
    font-size: 20px;
    font-weight: 800;
    margin-bottom: 6px;
  }
  .overlay-sub {
    font-size: 14px;
    opacity: 0.8;
  }

  .sr-only {
    position: absolute;
    width: 1px; height: 1px;
    padding: 0; margin: -1px;
    overflow: hidden; clip: rect(0,0,0,0);
    white-space: nowrap; border: 0;
  }
</style>
</head>
<body>
<div class="app">
  <div class="grid-wrap">
    <div id="grid" class="grid" role="grid" aria-label="–ê–∑–±—É–∫–∞"></div>
  </div>
</div>

<div id="audioOverlay" class="overlay" role="dialog" aria-modal="true" aria-label="–í–∫–ª—é—á–µ–Ω–∏–µ –∑–≤—É–∫–∞">
  <div class="overlay-card" role="button" tabindex="0" aria-label="–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫">
    <div class="overlay-emoji">üîä</div>
    <div class="overlay-title">–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫</div>
    <div class="overlay-sub">–ó–∞—Ç–µ–º –∫–æ—Å–Ω–∏—Ç–µ—Å—å –±—É–∫–≤—ã, —á—Ç–æ–±—ã —É—Å–ª—ã—à–∞—Ç—å —Ñ—Ä–∞–∑—É</div>
  </div>
</div>

<script>
  const DATA = [
    {l:'–ê', w:'–∞—Ä–±—É–∑', e:'üçâ', p:'–ê ‚Äî –∞—Ä–±—É–∑'},
    {l:'–ë', w:'–±–∞—Ä–∞–±–∞–Ω', e:'ü•Å', p:'–ë ‚Äî –±–∞—Ä–∞–±–∞–Ω'},
    {l:'–í', w:'–≤–µ–ª–æ—Å–∏–ø–µ–¥', e:'üö≤', p:'–í ‚Äî –≤–µ–ª–æ—Å–∏–ø–µ–¥'},
    {l:'–ì', w:'–≥—Ä—É—à–∞', e:'üçê', p:'–ì ‚Äî –≥—Ä—É—à–∞'},
    {l:'–î', w:'–¥–æ–º', e:'üè†', p:'–î ‚Äî –¥–æ–º'},
    {l:'–ï', w:'–µ–Ω–æ—Ç', e:'ü¶ù', p:'–ï ‚Äî –µ–Ω–æ—Ç'},
    {l:'–Å', w:'—ë–ª–∫–∞', e:'üéÑ', p:'–Å ‚Äî —ë–ª–∫–∞'},
    {l:'–ñ', w:'–∂–∏—Ä–∞—Ñ', e:'ü¶í', p:'–ñ ‚Äî –∂–∏—Ä–∞—Ñ'},
    {l:'–ó', w:'–∑–∞—è—Ü', e:'üê∞', p:'–ó ‚Äî –∑–∞—è—Ü'},
    {l:'–ò', w:'–∏–≥—Ä–∞', e:'üéÆ', p:'–ò ‚Äî –∏–≥—Ä–∞'},
    {l:'–ô', w:'–π–æ–≥–∞', e:'üßò', p:'–ô ‚Äî –π–æ–≥–∞'},
    {l:'–ö', w:'–∫–æ—Ç', e:'üê±', p:'–ö ‚Äî –∫–æ—Ç'},
    {l:'–õ', w:'–ª–∏—Å–∞', e:'ü¶ä', p:'–õ ‚Äî –ª–∏—Å–∞'},
    {l:'–ú', w:'–º—è—á', e:'‚öΩ', p:'–ú ‚Äî –º—è—á'},
    {l:'–ù', w:'–Ω–æ—Å–æ—Ä–æ–≥', e:'ü¶è', p:'–ù ‚Äî –Ω–æ—Å–æ—Ä–æ–≥'},
    {l:'–û', w:'–æ—Å—å–º–∏–Ω–æ–≥', e:'üêô', p:'–û ‚Äî –æ—Å—å–º–∏–Ω–æ–≥'},
    {l:'–ü', w:'–ø–æ–µ–∑–¥', e:'üöÇ', p:'–ü ‚Äî –ø–æ–µ–∑–¥'},
    {l:'–†', w:'—Ä–∞–∫–µ—Ç–∞', e:'üöÄ', p:'–† ‚Äî —Ä–∞–∫–µ—Ç–∞'},
    {l:'–°', w:'—Å–æ–ª–Ω—Ü–µ', e:'‚òÄÔ∏è', p:'–° ‚Äî —Å–æ–ª–Ω—Ü–µ'},
    {l:'–¢', w:'—Ç–∏–≥—Ä', e:'üêØ', p:'–¢ ‚Äî —Ç–∏–≥—Ä'},
    {l:'–£', w:'—É—Ç–∫–∞', e:'ü¶Ü', p:'–£ ‚Äî —É—Ç–∫–∞'},
    {l:'–§', w:'—Ñ–ª–∞–º–∏–Ω–≥–æ', e:'ü¶©', p:'–§ ‚Äî —Ñ–ª–∞–º–∏–Ω–≥–æ'},
    {l:'–•', w:'—Ö–æ–º—è–∫', e:'üêπ', p:'–• ‚Äî —Ö–æ–º—è–∫'},
    {l:'–¶', w:'—Ü–∏—Ä–∫', e:'üé™', p:'–¶ ‚Äî —Ü–∏—Ä–∫'},
    {l:'–ß', w:'—á–∞–π–Ω–∏–∫', e:'ü´ñ', p:'–ß ‚Äî —á–∞–π–Ω–∏–∫'},
    {l:'–®', w:'—à–∞—Ä–∏–∫', e:'üéà', p:'–® ‚Äî —à–∞—Ä–∏–∫'},
    {l:'–©', w:'—â—ë—Ç–∫–∞', e:'ü™•', p:'–© ‚Äî —â—ë—Ç–∫–∞'},
    {l:'–™', w:'—Ç–≤—ë—Ä–¥—ã–π –∑–Ω–∞–∫', e:'üß±', p:'–™ ‚Äî —Ç–≤—ë—Ä–¥—ã–π –∑–Ω–∞–∫'},
    {l:'–´', w:'–±—É–∫–≤–∞ —ã', e:'üôÇ', p:'–´ ‚Äî –±—É–∫–≤–∞ —ã'},
    {l:'–¨', w:'–º—è–≥–∫–∏–π –∑–Ω–∞–∫', e:'üß∏', p:'–¨ ‚Äî –º—è–≥–∫–∏–π –∑–Ω–∞–∫'},
    {l:'–≠', w:'—ç—Å–∫–∏–º–æ', e:'üç¶', p:'–≠ ‚Äî —ç—Å–∫–∏–º–æ'},
    {l:'–Æ', w:'—é–±–∫–∞', e:'üëó', p:'–Æ ‚Äî —é–±–∫–∞'},
    {l:'–Ø', w:'—è–≥–æ–¥–∞', e:'üçì', p:'–Ø ‚Äî —è–≥–æ–¥–∞'}
  ];

  const PALETTE = [
    '#FFECB3','#C8E6C9','#BBDEFB','#FFCDD2','#FFE0B2','#D1C4E9',
    '#B2EBF2','#F8BBD0','#DCEDC8','#FFF9C4','#E1BEE7','#B3E5FC'
  ];

  const app = document.querySelector('.app');
  const gridWrap = document.querySelector('.grid-wrap');
  const grid = document.getElementById('grid');
  const overlay = document.getElementById('audioOverlay');

  let audioEnabled = false;
  let currentCols = 6;

  function buildGrid() {
    const frag = document.createDocumentFragment();
    DATA.forEach((item, idx) => {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.setAttribute('role','button');
      tile.setAttribute('tabindex','0');
      tile.setAttribute('aria-label', item.p);
      tile.dataset.index = String(idx);
      tile.dataset.phrase = item.p;
      tile.style.background = PALETTE[idx % PALETTE.length];

      const c = document.createElement('div');
      c.className = 'tile-content';
      const letter = document.createElement('div');
      letter.className = 'letter';
      letter.textContent = item.l;
      const emoji = document.createElement('div');
      emoji.className = 'emoji';
      emoji.setAttribute('aria-hidden','true');
      emoji.textContent = item.e;
      c.appendChild(letter);
      c.appendChild(emoji);

      tile.appendChild(c);
      tile.addEventListener('click', () => activateTile(tile));
      tile.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          activateTile(tile);
        } else if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'].includes(e.key)) {
          e.preventDefault();
          handleArrows(e.key, parseInt(tile.dataset.index, 10));
        }
      });
      frag.appendChild(tile);
    });
    grid.appendChild(frag);
  }

  function handleArrows(key, index) {
    const count = DATA.length;
    const cols = currentCols || 6;
    const rows = Math.ceil(count / cols);
    let target = index;
    const col = index % cols;
    const row = Math.floor(index / cols);

    if (key === 'ArrowRight') {
      if (col < cols - 1 && index + 1 < count) target = index + 1;
      else {
        const start = row * cols;
        const end = Math.min(start + cols - 1, count - 1);
        target = start;
        if (target > end) target = end;
      }
    } else if (key === 'ArrowLeft') {
      if (col > 0) target = index - 1;
      else {
        const start = row * cols;
        const end = Math.min(start + cols - 1, count - 1);
        target = end;
      }
    } else if (key === 'ArrowDown') {
      let nr = Math.min(row + 1, rows - 1);
      target = nr * cols + col;
      if (target >= count) target = count - 1;
    } else if (key === 'ArrowUp') {
      let nr = Math.max(row - 1, 0);
      target = nr * cols + col;
      if (target >= count) target = count - 1;
    } else if (key === 'Home' || key === 'PageUp') {
      target = 0;
    } else if (key === 'End' || key === 'PageDown') {
      target = count - 1;
    }
    const el = grid.children[target];
    if (el) el.focus();
  }

  const synth = window.speechSynthesis;
  let selectedVoice = null;

  function pickVoice() {
    const voices = synth.getVoices();
    if (!voices || voices.length === 0) return null;
    let v = voices.find(v => v.lang && /^(ru[-_]?RU)$/i.test(v.lang));
    if (!v) v = voices.find(v => v.lang && /^ru/i.test(v.lang));
    if (!v) v = voices.find(v => v.lang && /ru/i.test(v.lang));
    if (!v) v = voices[0];
    return v || null;
  }

  function refreshVoice() {
    selectedVoice = pickVoice();
  }

  function speak(text) {
    if (!audioEnabled || !text) return;
    try {
      synth.cancel();
    } catch(e) {}
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'ru-RU';
    if (!selectedVoice) refreshVoice();
    if (selectedVoice) u.voice = selectedVoice;
    u.rate = 0.95;
    u.pitch = 1.0;
    u.volume = 1.0;
    requestAnimationFrame(() => {
      try { synth.speak(u); } catch(e) {}
    });
  }

  function activateTile(tile) {
    const phrase = tile.dataset.phrase;
    speak(phrase);
  }

  function computeLayout() {
    const wrapStyles = getComputedStyle(gridWrap);
    let pad = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pad')) || 12;
    let gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 10;

    const vw = gridWrap.clientWidth;
    const vh = gridWrap.clientHeight;

    let best = null;

    function tryRange(minCols, maxCols, padVal, gapVal) {
      for (let cols = minCols; cols <= maxCols; cols++) {
        const cellSize = Math.floor((vw - (cols + 1) * gapVal - 2 * padVal) / cols);
        if (cellSize <= 0) continue;
        const rows = Math.ceil(DATA.length / cols);
        const totalHeight = rows * cellSize + (rows + 1) * gapVal + 2 * padVal;
        if (totalHeight <= vh) {
          if (!best || cellSize > best.cellSize) {
            best = { cols, cellSize, pad: padVal, gap: gapVal };
          }
        }
      }
    }

    tryRange(3, 10, 12, 10);
    if (!best) {
      gridWrap.classList.add('compact');
      tryRange(3, 10, 8, 6);
    } else {
      gridWrap.classList.remove('compact');
    }
    if (!best) {
      tryRange(3, 12, 6, 4);
    }

    if (!best) {
      const cols = 10;
      const cellSize = Math.floor((vw - (cols + 1) * 4 - 2 * 6) / cols);
      best = { cols, cellSize: Math.max(cellSize, 32), pad: 6, gap: 4 };
    }

    currentCols = best.cols;
    document.documentElement.style.setProperty('--pad', best.pad + 'px');
    document.documentElement.style.setProperty('--gap', best.gap + 'px');
    document.documentElement.style.setProperty('--cell-size', best.cellSize + 'px');
    grid.style.gridTemplateColumns = `repeat(${best.cols}, var(--cell-size))`;
  }

  function debounce(fn, wait = 120) {
    let t;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(null, args), wait);
    };
  }

  function enableAudioFromEvent(ev) {
    if (audioEnabled) return;
    audioEnabled = true;
    const x = ev.touches && ev.touches[0] ? ev.touches[0].clientX : ev.clientX;
    const y = ev.touches && ev.touches[0] ? ev.touches[0].clientY : ev.clientY;

    overlay.classList.add('hide');
    overlay.style.pointerEvents = 'none';

    requestAnimationFrame(() => {
      const el = document.elementFromPoint(x, y);
      const tile = el && (el.classList.contains('tile') ? el : el.closest && el.closest('.tile'));
      if (tile) {
        setTimeout(() => {
          tile.click();
        }, 0);
      }
    });
  }

  function setupOverlay() {
    const card = overlay.querySelector('.overlay-card');
    const anyActivate = (e) => {
      e.preventDefault();
      enableAudioFromEvent(e);
    };
    overlay.addEventListener('pointerdown', anyActivate, { passive: false });
    card.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        anyActivate(e);
      }
    }, { passive: false });
  }

  function init() {
    buildGrid();
    computeLayout();
    refreshVoice();
    if (typeof window.speechSynthesis !== 'undefined') {
      window.speechSynthesis.onvoiceschanged = () => {
        refreshVoice();
      };
    }
  }

  const onResize = debounce(() => computeLayout(), 120);

  window.addEventListener('resize', onResize);
  window.addEventListener('orientationchange', () => setTimeout(() => computeLayout(), 50));
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', onResize);
  }

  setupOverlay();
  document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>